# This is the main file you will be running. It contains the integration of front-end
# using streamlit with the backend of the quiz app.
#After running this code, copy the link into your virtual environment command prompt

from langchain.llms import openai
import os
os.environ["OPENAI_API_KEY"] = "<Your API Key>"
openai.api_key = os.getenv("OPENAI_API_KEY")

# importing necessary packages/libraries
from langchain import PromptTemplate
from langchain.chains import LLMChain
from langchain.chat_models import ChatOpenAI
import streamlit as st
import re

# creating our prompt which we will use for quiz generation (questions and answers)
def create_the_quiz_prompt_template():
    """Create the prompt template for the quiz app."""

    template = """
    You are an expert quiz maker for any major quiz contexts, especially technical fields. Let's think step by step and
    create a quiz with {num_questions} multiple-choice questions about the following concept/content: {quiz_context}.

    The format of the quiz could be one of the following:
    - Multiple-choice: 
    - Questions:
        <Question1>: <a. Answer 1>, <b. Answer 2>, <c. Answer 3>, <d. Answer 4>
        <Question2>: <a. Answer 1>, <b. Answer 2>, <c. Answer 3>, <d. Answer 4>
        ....
    - Answers:
        <Answer1>: <a|b|c|d>
        <Answer2>: <a|b|c|d>
        ....
        Example:
        - Questions:
        - 1. What is the time complexity of a binary search tree?
            a. O(n)
            b. O(log n)
            c. O(n^2)
            d. O(1)
        - Answers: 
            1. b
    """
    prompt = PromptTemplate.from_template(template)
    prompt.format(num_questions=3, quiz_context="Data Structures in Python Programming")

    return prompt


def create_quiz_chain(prompt_template, llm):
    """Creates the chain for the quiz app."""
    return LLMChain(llm=llm, prompt=prompt_template)

# need to split questions from answers generated by the API for integration into frontend.
def split_questions_answers(quiz_response):
    """Function that splits the questions and answers from the quiz response."""
    questions = quiz_response.split("Answers:")[0]
    answers = quiz_response.split("Answers:")[1]
    return questions, answers


def main():
    st.title("MCQ Quiz App")
    st.write("This app creates a quiz based on your given subject.")

    prompt_template = create_the_quiz_prompt_template()
    llm = ChatOpenAI()
    chain = create_quiz_chain(prompt_template, llm)
    context = st.text_area("Enter the context for the quiz")
    num_questions = st.number_input("Enter the number of questions", min_value=1, max_value=10, value=3)

    if st.button("Generate Quiz"):
        quiz_response = chain.run(num_questions=num_questions, quiz_context=context)
        st.subheader("Quiz Generated!")
        questions, answers = split_questions_answers(quiz_response)
        st.session_state.answers = answers
        st.session_state.questions = questions
        st.text(questions)
        st.subheader('Please choose your answers for the respective questions below:')
        user_answers = []
#        if "radio" not in st.session_state:
#            st.session_state["radio"] = 0
#        if 'selected_options' not in st.session_state:
#            st.session_state.selected_options = {f"group_{i}": None for i in range(num_questions)}
#        load = st.checkbox('Start Answering:')
#        if load:
#            st.write("lets begin...")
    load = st.checkbox("answer below")
    selected_options = []
    if load:
        st.markdown(st.session_state.questions)
        num_groups = num_questions
        options = ["a", "b", "c", "d"]

        st.title("Radio Button Answering Options:")

        # Loop through each group and render radio buttons
        for group in range(num_groups):
            selected_option = st.radio(f"Select an option for question {group + 1}", options,
                                        key=f"question_{group}")
            st.write(f"Selected option in question {group + 1}: {selected_option}")
            selected_options.append(selected_option)
        st.write(selected_options)
        print(selected_options)


    score = 0

    if st.button("Show Answers"):
        st.markdown(st.session_state.questions)
        st.write("---- ANSWERS ----")
        st.markdown(st.session_state.answers)
        gen_list = re.findall('[a-z]',st.session_state.answers)
        gen_list = gen_list[:num_questions]
#        print(gen_list)
#        print(selected_options)
        for i in range(num_questions):
            if gen_list[i] == selected_options[i]:
                score += 1
        st.text("YOUR FINAL SCORE:")
        st.write(f"{score} out of {num_questions}")
        score = 0



if __name__ == "__main__":
    main()
